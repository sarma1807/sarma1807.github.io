<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D City Simulation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    #canvas {
      display: block;
      cursor: grab;
    }

    #canvas.grabbing {
      cursor: grabbing;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 10;
      display: none;
    }

    #branding {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 2px;
      text-shadow: 0 0 20px rgba(255,0,128,0.5);
    }

    #info {
      position: absolute;
      top: 55px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
    }

    #info div {
      margin-top: 5px;
    }

    #info .controls {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.8;
    }

    #toggleBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #87ceeb;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }

    #toggleBtn:hover {
      transform: scale(1.05);
    }

    #toggleBtn.night {
      background: #1a1a3e;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      min-width: 300px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      font-weight: bold;
    }

    .control-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .control-group .value-display {
      display: inline-block;
      margin-left: 10px;
      font-size: 14px;
      color: #87ceeb;
    }

    #generateBtn {
      width: 100%;
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    #generateBtn:hover {
      background: #45a049;
      transform: scale(1.02);
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="loading">Loading City...</div>
    <canvas id="canvas"></canvas>
    <div id="branding">oramad</div>
    <div id="info">
      <div><strong>3D City Simulation</strong></div>
      <div style="margin-top: 10px;">üè¢ <span id="buildingCount">50</span> Buildings</div>
      <div>üöó <span id="carCount">25</span> Cars</div>
      <div>üö∂ <span id="pedCount">67</span> Pedestrians</div>
      <div class="controls">
        Click & drag to rotate<br/>
        Scroll to zoom
      </div>
    </div>
    <button id="toggleBtn">üåô Night</button>
    <div id="controls">
      <div class="control-group">
        <label>üè¢ Buildings: <span class="value-display" id="buildingValue">50</span></label>
        <input type="range" id="buildingSlider" min="3" max="100" value="50">
      </div>
      <div class="control-group">
        <label>üöó Cars: <span class="value-display" id="carValue">25</span></label>
        <input type="range" id="carSlider" min="3" max="100" value="25">
      </div>
      <div class="control-group">
        <label>üö∂ Pedestrians: <span class="value-display" id="pedValue">67</span></label>
        <input type="range" id="pedSlider" min="3" max="100" value="67">
      </div>
      <div class="control-group">
        <label style="display: flex; align-items: center; cursor: pointer;">
          <input type="checkbox" id="mountainsCheckbox" style="margin-right: 10px; cursor: pointer; width: 18px; height: 18px;">
          üèîÔ∏è Mountains
        </label>
      </div>
      <button id="generateBtn">Generate City</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const container = document.getElementById('container');
    const toggleBtn = document.getElementById('toggleBtn');
    const loading = document.getElementById('loading');
    const generateBtn = document.getElementById('generateBtn');
    const buildingSlider = document.getElementById('buildingSlider');
    const carSlider = document.getElementById('carSlider');
    const pedSlider = document.getElementById('pedSlider');
    const buildingValue = document.getElementById('buildingValue');
    const carValue = document.getElementById('carValue');
    const pedValue = document.getElementById('pedValue');
    const buildingCount = document.getElementById('buildingCount');
    const carCount = document.getElementById('carCount');
    const pedCount = document.getElementById('pedCount');
    const mountainsCheckbox = document.getElementById('mountainsCheckbox');
    
    let scene, camera, renderer;
    let isDragging = false;
    let isNight = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngle = { theta: Math.PI / 4, phi: Math.PI / 6 };
    let cameraDistance = 70;
    let cars = [];
    let pedestrians = [];
    let buildings = [];
    let ambientLight, sunLight;
    let roads = [];
    let ground;
    let mountains = [];
    let planes = [];
    let planeSpawnTimer = 0;
    
    let numBuildings = 50;
    let numCars = 25;
    let numPedestrians = 67;

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

      // Camera
      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(50, 40, 50);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Lights
      ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
      sunLight.position.set(50, 100, 50);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -100;
      sunLight.shadow.camera.right = 100;
      sunLight.shadow.camera.top = 100;
      sunLight.shadow.camera.bottom = -100;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c4e });
      ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Road system
      const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      roads = [];
      
      // Main roads (horizontal)
      for (let i = -4; i <= 4; i += 2) {
        const road = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 8),
          roadMaterial
        );
        road.rotation.x = -Math.PI / 2;
        road.position.set(0, 0.01, i * 12);
        road.receiveShadow = true;
        scene.add(road);
        roads.push({ x: 0, z: i * 12, width: 200, depth: 8, horizontal: true });
      }

      // Vertical roads
      for (let i = -4; i <= 4; i += 2) {
        const road = new THREE.Mesh(
          new THREE.PlaneGeometry(8, 200),
          roadMaterial
        );
        road.rotation.x = -Math.PI / 2;
        road.position.set(i * 12, 0.01, 0);
        road.receiveShadow = true;
        scene.add(road);
        roads.push({ x: i * 12, z: 0, width: 8, depth: 200, horizontal: false });
      }

      // Road markings
      const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      roads.forEach(road => {
        if (road.horizontal) {
          for (let x = -90; x < 90; x += 10) {
            const marking = new THREE.Mesh(
              new THREE.PlaneGeometry(4, 0.3),
              markingMaterial
            );
            marking.rotation.x = -Math.PI / 2;
            marking.position.set(x, 0.02, road.z);
            scene.add(marking);
          }
        } else {
          for (let z = -90; z < 90; z += 10) {
            const marking = new THREE.Mesh(
              new THREE.PlaneGeometry(0.3, 4),
              markingMaterial
            );
            marking.rotation.x = -Math.PI / 2;
            marking.position.set(road.x, 0.02, z);
            scene.add(marking);
          }
        }
      });

      generateCity();
      
      // Initialize planes - start with 3-4 planes in the sky
      const initialPlanes = 3 + Math.floor(Math.random() * 2);
      for (let i = 0; i < initialPlanes; i++) {
        createPlane();
      }
      
      setupEventListeners();
      animate();
      loading.style.display = 'none';
    }

    function generateCity() {
      // Clear existing city elements
      buildings.forEach(b => scene.remove(b));
      cars.forEach(c => scene.remove(c));
      pedestrians.forEach(p => scene.remove(p));
      mountains.forEach(m => scene.remove(m));
      buildings = [];
      cars = [];
      pedestrians = [];
      mountains = [];

      // Generate mountains if checkbox is checked
      if (mountainsCheckbox.checked) {
        generateMountains();
      }

      // Building colors
      const buildingColors = [
        0x8b9dc3, 0xa8b5c7, 0xc7d3dd, 0x9ba8b5,
        0xb5c7d3, 0xdee5ed, 0x7a8a9e, 0x6b7c8f
      ];

      // Generate buildings
      const buildingPositions = [];
      for (let x = -4; x <= 4; x++) {
        for (let z = -4; z <= 4; z++) {
          if (x % 2 === 0 || z % 2 === 0) continue;
          buildingPositions.push({ x: x * 12, z: z * 12 });
        }
      }

      for (let i = 0; i < numBuildings; i++) {
        const pos = buildingPositions[i % buildingPositions.length];
        const offsetX = (Math.random() - 0.5) * 6;
        const offsetZ = (Math.random() - 0.5) * 6;
        const height = 5 + Math.random() * 25;
        const width = 2 + Math.random() * 3;
        const depth = 2 + Math.random() * 3;
        
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshLambertMaterial({
          color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
        });
        const building = new THREE.Mesh(geometry, material);
        building.position.set(pos.x + offsetX, height / 2, pos.z + offsetZ);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
        buildings.push(building);
        
        // Windows
        const windowMaterialLit = new THREE.MeshBasicMaterial({ color: 0xffff99 });
        const windowMaterialOff = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const floors = Math.floor(height / 3);
        building.userData.windows = [];
        
        // Random colors for night mode lights
        const lightColors = [
          0xffff99, // warm yellow
          0xff6b6b, // red
          0x4ecdc4, // cyan
          0x45b7d1, // blue
          0xf9ca24, // yellow
          0xff9ff3, // pink
          0x48dbfb, // light blue
          0xfeca57, // orange
          0xff6348, // coral
          0x1dd1a1, // green
          0xee5a6f, // rose
          0xc44569  // purple
        ];
        
        for (let f = 1; f < floors; f++) {
          for (let side = 0; side < 4; side++) {
            const windowSize = 0.3;
            const isLit = Math.random() > 0.3;
            const windowMat = isLit ? windowMaterialLit.clone() : windowMaterialOff.clone();
            const window1 = new THREE.Mesh(
              new THREE.PlaneGeometry(windowSize, windowSize),
              windowMat
            );
            
            const yPos = (f * 3) - height / 2 + 1.5;
            if (side === 0) {
              window1.position.set(width / 2 + 0.01, yPos, 0);
              window1.rotation.y = Math.PI / 2;
            } else if (side === 1) {
              window1.position.set(-width / 2 - 0.01, yPos, 0);
              window1.rotation.y = -Math.PI / 2;
            } else if (side === 2) {
              window1.position.set(0, yPos, depth / 2 + 0.01);
            } else {
              window1.position.set(0, yPos, -depth / 2 - 0.01);
              window1.rotation.y = Math.PI;
            }
            building.add(window1);
            
            // Store window data for blinking effect with random color
            const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
            building.userData.windows.push({
              mesh: window1,
              isLit: isLit,
              blinkTimer: Math.random() * 200,
              blinkDuration: 0,
              baseColor: randomColor
            });
          }
        }
      }

      // Cars
      const carGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.8);
      const carColors = [0xff0000, 0x0000ff, 0xffff00, 0x00ff00, 0xff00ff, 0x00ffff, 0xffa500, 0x800080];
      
      for (let i = 0; i < numCars; i++) {
        const material = new THREE.MeshLambertMaterial({
          color: carColors[Math.floor(Math.random() * carColors.length)]
        });
        const car = new THREE.Mesh(carGeometry, material);
        car.castShadow = true;
        
        const road = roads[Math.floor(Math.random() * roads.length)];
        if (road.horizontal) {
          car.position.set(
            (Math.random() - 0.5) * 180,
            0.4,
            road.z + (Math.random() - 0.5) * 3
          );
          car.userData = {
            speed: 0.1 + Math.random() * 0.15,
            direction: Math.random() > 0.5 ? 1 : -1,
            horizontal: true
          };
        } else {
          car.position.set(
            road.x + (Math.random() - 0.5) * 3,
            0.4,
            (Math.random() - 0.5) * 180
          );
          car.rotation.y = Math.PI / 2;
          car.userData = {
            speed: 0.1 + Math.random() * 0.15,
            direction: Math.random() > 0.5 ? 1 : -1,
            horizontal: false
          };
        }
        
        scene.add(car);
        cars.push(car);
      }

      // Pedestrians
      const pedGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
      const pedColors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xee5a6f, 0xc44569];
      
      for (let i = 0; i < numPedestrians; i++) {
        const material = new THREE.MeshLambertMaterial({
          color: pedColors[Math.floor(Math.random() * pedColors.length)]
        });
        const ped = new THREE.Mesh(pedGeometry, material);
        ped.castShadow = true;
        
        const road = roads[Math.floor(Math.random() * roads.length)];
        const side = Math.random() > 0.5 ? 1 : -1;
        
        if (road.horizontal) {
          ped.position.set(
            (Math.random() - 0.5) * 180,
            0.75,
            road.z + side * 5 + (Math.random() - 0.5) * 2
          );
          ped.userData = {
            speed: 0.02 + Math.random() * 0.03,
            direction: Math.random() > 0.5 ? 1 : -1,
            horizontal: true
          };
        } else {
          ped.position.set(
            road.x + side * 5 + (Math.random() - 0.5) * 2,
            0.75,
            (Math.random() - 0.5) * 180
          );
          ped.userData = {
            speed: 0.02 + Math.random() * 0.03,
            direction: Math.random() > 0.5 ? 1 : -1,
            horizontal: false
          };
        }
        
        scene.add(ped);
        pedestrians.push(ped);
      }

      // Update counts
      buildingCount.textContent = numBuildings;
      carCount.textContent = numCars;
      pedCount.textContent = numPedestrians;
    }

    function generateMountains() {
      const mountainColor = new THREE.Color(0x5a6b7c);
      const snowColor = new THREE.Color(0xffffff);
      
      // Create mountains around the city perimeter
      const mountainPositions = [
        { x: 0, z: -120, scale: 1.2 },
        { x: -80, z: -100, scale: 1.0 },
        { x: 80, z: -100, scale: 0.9 },
        { x: -120, z: 0, scale: 1.1 },
        { x: 120, z: 0, scale: 1.0 },
        { x: -80, z: 100, scale: 0.95 },
        { x: 80, z: 100, scale: 1.15 },
        { x: 0, z: 120, scale: 1.05 }
      ];

      mountainPositions.forEach(pos => {
        // Create main mountain peak with wider base
        const height = 45 * pos.scale;
        const baseRadius = 35 * pos.scale;
        const geometry = new THREE.ConeGeometry(baseRadius, height, 8);
        const material = new THREE.MeshLambertMaterial({ color: mountainColor });
        const mountain = new THREE.Mesh(geometry, material);
        mountain.position.set(pos.x, height / 2, pos.z);
        mountain.castShadow = true;
        mountain.receiveShadow = true;
        scene.add(mountain);
        mountains.push(mountain);

        // Add snow cap - wider to match mountain
        const snowCapGeometry = new THREE.ConeGeometry(14 * pos.scale, 18 * pos.scale, 8);
        const snowCapMaterial = new THREE.MeshLambertMaterial({ color: snowColor });
        const snowCap = new THREE.Mesh(snowCapGeometry, snowCapMaterial);
        snowCap.position.set(pos.x, height - 7, pos.z);
        scene.add(snowCap);
        mountains.push(snowCap);

        // Add smaller adjacent peaks for variety with wider bases
        if (Math.random() > 0.5) {
          const smallHeight = 30 * pos.scale;
          const smallBaseRadius = 25 * pos.scale;
          const smallGeometry = new THREE.ConeGeometry(smallBaseRadius, smallHeight, 6);
          const smallMountain = new THREE.Mesh(smallGeometry, material);
          const offsetX = (Math.random() - 0.5) * 40;
          const offsetZ = (Math.random() - 0.5) * 40;
          smallMountain.position.set(pos.x + offsetX, smallHeight / 2, pos.z + offsetZ);
          smallMountain.castShadow = true;
          smallMountain.receiveShadow = true;
          scene.add(smallMountain);
          mountains.push(smallMountain);
        }
      });
    }

    function createPlane() {
      // Create plane body
      const planeGroup = new THREE.Group();
      
      // Fuselage
      const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);
      const fuselageMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
      const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
      fuselage.rotation.z = Math.PI / 2;
      planeGroup.add(fuselage);
      
      // Wings
      const wingGeometry = new THREE.BoxGeometry(6, 0.1, 1.5);
      const wingMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
      const wings = new THREE.Mesh(wingGeometry, wingMaterial);
      planeGroup.add(wings);
      
      // Tail
      const tailGeometry = new THREE.BoxGeometry(1.5, 0.1, 1);
      const tail = new THREE.Mesh(tailGeometry, wingMaterial);
      tail.position.set(-1.2, 0.5, 0);
      planeGroup.add(tail);
      
      // Vertical stabilizer
      const stabGeometry = new THREE.BoxGeometry(0.1, 1, 0.8);
      const stab = new THREE.Mesh(stabGeometry, wingMaterial);
      stab.position.set(-1.2, 0.5, 0);
      planeGroup.add(stab);
      
      // Position plane high above buildings (buildings max height ~30)
      const altitude = 32 + Math.random() * 8;
      
      // Random flight path - either horizontal or diagonal
      const pathType = Math.random();
      let startX, startZ, endX, endZ, direction;
      
      if (pathType < 0.25) {
        // West to East
        startX = -150;
        endX = 150;
        startZ = (Math.random() - 0.5) * 100;
        endZ = startZ;
        direction = new THREE.Vector3(1, 0, 0);
      } else if (pathType < 0.5) {
        // East to West
        startX = 150;
        endX = -150;
        startZ = (Math.random() - 0.5) * 100;
        endZ = startZ;
        direction = new THREE.Vector3(-1, 0, 0);
      } else if (pathType < 0.75) {
        // North to South
        startZ = -150;
        endZ = 150;
        startX = (Math.random() - 0.5) * 100;
        endX = startX;
        direction = new THREE.Vector3(0, 0, 1);
      } else {
        // South to North
        startZ = 150;
        endZ = -150;
        startX = (Math.random() - 0.5) * 100;
        endX = startX;
        direction = new THREE.Vector3(0, 0, -1);
      }
      
      planeGroup.position.set(startX, altitude, startZ);
      
      // Rotate plane to face direction
      const angle = Math.atan2(direction.z, direction.x);
      planeGroup.rotation.y = angle;
      
      planeGroup.userData = {
        startX: startX,
        startZ: startZ,
        endX: endX,
        endZ: endZ,
        speed: 0.3 + Math.random() * 0.2,
        progress: Math.random() * 100 // Random starting progress for initial planes
      };
      
      planeGroup.castShadow = true;
      scene.add(planeGroup);
      planes.push(planeGroup);
    }

    function setupEventListeners() {
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('wheel', onWheel);
      toggleBtn.addEventListener('click', toggleDayNight);
      generateBtn.addEventListener('click', onGenerate);
      window.addEventListener('resize', onResize);
      
      // Slider listeners
      buildingSlider.addEventListener('input', (e) => {
        buildingValue.textContent = e.target.value;
      });
      carSlider.addEventListener('input', (e) => {
        carValue.textContent = e.target.value;
      });
      pedSlider.addEventListener('input', (e) => {
        pedValue.textContent = e.target.value;
      });
    }

    function onGenerate() {
      numBuildings = parseInt(buildingSlider.value);
      numCars = parseInt(carSlider.value);
      numPedestrians = parseInt(pedSlider.value);
      generateCity();
    }

    function onMouseDown(e) {
      isDragging = true;
      canvas.classList.add('grabbing');
      previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
      if (!e.buttons) return;

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      cameraAngle.theta += deltaX * 0.005;
      cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi - deltaY * 0.005));

      previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
      isDragging = false;
      canvas.classList.remove('grabbing');
    }

    function onWheel(e) {
      e.preventDefault();
      cameraDistance = Math.max(20, Math.min(150, cameraDistance + e.deltaY * 0.05));
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleDayNight() {
      isNight = !isNight;
      
      if (isNight) {
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog.color = new THREE.Color(0x0a0a1a);
        ambientLight.intensity = 0.2;
        sunLight.intensity = 0.1;
        sunLight.color = new THREE.Color(0x6666ff);
        toggleBtn.textContent = '‚òÄÔ∏è Day';
        toggleBtn.classList.add('night');
      } else {
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog.color = new THREE.Color(0x87ceeb);
        ambientLight.intensity = 0.6;
        sunLight.intensity = 0.8;
        sunLight.color = new THREE.Color(0xffffff);
        toggleBtn.textContent = 'üåô Night';
        toggleBtn.classList.remove('night');
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update camera position
      camera.position.x = cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);
      camera.position.y = cameraDistance * Math.cos(cameraAngle.phi);
      camera.position.z = cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
      camera.lookAt(0, 0, 0);

      // Update window blinking effect in night mode
      if (isNight) {
        buildings.forEach(building => {
          if (building.userData.windows) {
            building.userData.windows.forEach(windowData => {
              windowData.blinkTimer++;
              
              // Random chance to start blinking
              if (windowData.blinkTimer > 150 && Math.random() < 0.005) {
                windowData.blinkDuration = 10 + Math.random() * 20;
                windowData.blinkTimer = 0;
              }
              
              // Handle blink effect with color
              if (windowData.blinkDuration > 0) {
                windowData.blinkDuration--;
                const blinkIntensity = Math.sin(windowData.blinkDuration * 0.5) * 0.5 + 0.5;
                if (windowData.isLit) {
                  // Apply blinking to the base color
                  const color = new THREE.Color(windowData.baseColor);
                  const brightness = 0.4 + blinkIntensity * 0.6;
                  color.multiplyScalar(brightness);
                  windowData.mesh.material.color.copy(color);
                }
              } else if (windowData.isLit) {
                // Return to base color
                windowData.mesh.material.color.setHex(windowData.baseColor);
              }
            });
          }
        });
      } else {
        // In day mode, show yellow lights
        buildings.forEach(building => {
          if (building.userData.windows) {
            building.userData.windows.forEach(windowData => {
              if (windowData.isLit) {
                windowData.mesh.material.color.setHex(0xffff99);
              }
            });
          }
        });
      }

      // Handle plane spawning - maintain 3-4 planes at all times
      const minPlanes = 3;
      const maxPlanes = 4;
      
      if (planes.length < minPlanes || (planes.length < maxPlanes && Math.random() < 0.02)) {
        createPlane();
      }

      // Update planes
      planes.forEach((plane, index) => {
        plane.userData.progress += plane.userData.speed;
        const t = plane.userData.progress / 300;
        
        plane.position.x = plane.userData.startX + (plane.userData.endX - plane.userData.startX) * t;
        plane.position.z = plane.userData.startZ + (plane.userData.endZ - plane.userData.startZ) * t;
        
        // Remove plane when it's far off screen
        if (t > 1) {
          scene.remove(plane);
          planes.splice(index, 1);
        }
      });

      // Update cars
      cars.forEach(car => {
        if (car.userData.horizontal) {
          car.position.x += car.userData.speed * car.userData.direction;
          if (car.position.x > 100) car.position.x = -100;
          if (car.position.x < -100) car.position.x = 100;
        } else {
          car.position.z += car.userData.speed * car.userData.direction;
          if (car.position.z > 100) car.position.z = -100;
          if (car.position.z < -100) car.position.z = 100;
        }
      });

      // Update pedestrians
      pedestrians.forEach(ped => {
        if (ped.userData.horizontal) {
          ped.position.x += ped.userData.speed * ped.userData.direction;
          if (ped.position.x > 100) ped.position.x = -100;
          if (ped.position.x < -100) ped.position.x = 100;
        } else {
          ped.position.z += ped.userData.speed * ped.userData.direction;
          if (ped.position.z > 100) ped.position.z = -100;
          if (ped.position.z < -100) ped.position.z = 100;
        }
      });

      renderer.render(scene, camera);
    }

    // Start the simulation
    init();
  </script>
</body>
</html>